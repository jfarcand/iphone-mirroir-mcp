// Copyright 2026 jfarcand@apache.org
// Licensed under the Apache License, Version 2.0
//
// ABOUTME: Autonomous DFS explorer that systematically traverses app screens via graph-based backtracking.
// ABOUTME: Each step() call performs one exploration action: tap an unvisited element or backtrack.

import Foundation
import HelperLib

/// Result of a single DFS exploration step.
enum ExploreStepResult: Sendable {
    /// Exploration continues — an action was performed and a new/revisited screen was reached.
    case `continue`(description: String)
    /// Backtracked from one screen to another after exhausting elements.
    case backtracked(from: String, to: String)
    /// Exploration paused due to a budget constraint or external condition.
    case paused(reason: String)
    /// Exploration is complete — all reachable screens have been visited.
    case finished(bundle: SkillBundle)
}

/// Autonomous DFS explorer that systematically traverses app screens.
/// Each call to `step()` performs one exploration action: OCR the current screen,
/// decide what to tap (or backtrack), execute the action, and record the result.
/// Follows the Session Accumulator pattern with NSLock protection.
final class DFSExplorer: @unchecked Sendable {

    private let graph: NavigationGraph
    private let session: ExplorationSession
    private let budget: ExplorationBudget
    private let windowSize: CGSize
    private var backtrackStack: [String] = []
    private var startTime: Date = Date()
    private var actionCount: Int = 0
    private var actionsOnCurrentScreen: Int = 0
    private var isFinished: Bool = false
    private let lock = NSLock()

    /// Initialize the DFS explorer.
    ///
    /// - Parameters:
    ///   - session: The exploration session tracking screens and graph state.
    ///   - budget: Exploration budget limits.
    ///   - windowSize: Size of the target window for scroll coordinate computation.
    init(session: ExplorationSession, budget: ExplorationBudget, windowSize: CGSize = CGSize(width: 410, height: 890)) {
        self.session = session
        self.graph = session.currentGraph
        self.budget = budget
        self.windowSize = windowSize
    }

    /// Record the exploration start time. Call once after the initial screen capture.
    func markStarted() {
        lock.lock()
        defer { lock.unlock() }
        startTime = Date()
        if graph.started {
            backtrackStack = [graph.currentFingerprint]
        }
    }

    /// Perform one DFS exploration step.
    /// OCRs the current screen, decides what to do, executes the action, and records the result.
    ///
    /// - Parameters:
    ///   - describer: Screen describer for OCR.
    ///   - input: Input provider for tap/press_key actions.
    ///   - strategy: Exploration strategy for element ranking and classification.
    /// - Returns: The result of this step.
    func step<S: ExplorationStrategy>(
        describer: ScreenDescribing,
        input: InputProviding,
        strategy: S.Type
    ) -> ExploreStepResult {
        lock.lock()
        let finished = isFinished
        let elapsed = Int(Date().timeIntervalSince(startTime))
        let depth = backtrackStack.count - 1
        let screenCount = graph.nodeCount
        lock.unlock()

        guard !finished else {
            return .finished(bundle: generateBundle())
        }

        // Check budget
        if budget.isExhausted(depth: depth, screenCount: screenCount, elapsedSeconds: elapsed) {
            lock.lock()
            isFinished = true
            lock.unlock()
            return .finished(bundle: generateBundle())
        }

        // OCR current screen, dismissing any alert that may be present
        guard let result = dismissAlertIfPresent(describer: describer, input: input) else {
            return .paused(reason: "Failed to capture screen")
        }

        let currentFP = graph.currentFingerprint

        // Get unvisited elements for current screen
        let unvisited = graph.unvisitedElements(for: currentFP)
        let screenType = strategy.classifyScreen(elements: result.elements, hints: result.hints)
        let ranked = strategy.rankElements(
            elements: unvisited, icons: result.icons,
            visitedElements: graph.node(for: currentFP)?.visitedElements ?? [],
            depth: depth, screenType: screenType
        )
        let actionable = ranked.filter { !strategy.shouldSkip(elementText: $0.text) }

        lock.lock()
        let currentActions = actionsOnCurrentScreen
        lock.unlock()

        // Check if we should tap an element or backtrack
        if let target = actionable.first, currentActions < budget.maxActionsPerScreen {
            return performTap(
                target: target, currentFP: currentFP,
                input: input, describer: describer, strategy: strategy,
                result: result
            )
        }

        // Try scrolling to reveal hidden elements before backtracking
        if let scrollResult = performScrollIfAvailable(
            currentFP: currentFP, input: input, describer: describer
        ) {
            return scrollResult
        }

        // No more elements, scroll exhausted — backtrack
        return performBacktrack(
            currentFP: currentFP, input: input,
            describer: describer, strategy: strategy, hints: result.hints
        )
    }

    /// Whether the exploration has completed.
    var completed: Bool {
        lock.lock()
        defer { lock.unlock() }
        return isFinished
    }

    /// Current exploration statistics.
    var stats: (nodeCount: Int, edgeCount: Int, actionCount: Int, elapsedSeconds: Int) {
        lock.lock()
        defer { lock.unlock() }
        return (
            nodeCount: graph.nodeCount,
            edgeCount: graph.edgeCount,
            actionCount: actionCount,
            elapsedSeconds: Int(Date().timeIntervalSince(startTime))
        )
    }

    // MARK: - Private Actions

    private func performTap<S: ExplorationStrategy>(
        target: TapPoint,
        currentFP: String,
        input: InputProviding,
        describer: ScreenDescribing,
        strategy: S.Type,
        result: ScreenDescriber.DescribeResult
    ) -> ExploreStepResult {
        // Mark element as visited before tapping
        graph.markElementVisited(fingerprint: currentFP, elementText: target.text)

        // Tap the element
        _ = input.tap(x: target.tapX, y: target.tapY)

        // Wait for screen to settle
        usleep(EnvConfig.stepSettlingDelayMs * 1000)

        // OCR the new screen, dismissing any alert triggered by the tap
        guard let afterResult = dismissAlertIfPresent(describer: describer, input: input) else {
            return .paused(reason: "Failed to capture screen after tap")
        }

        let screenType = strategy.classifyScreen(
            elements: afterResult.elements, hints: afterResult.hints
        )

        // Record transition in graph
        let transition = graph.recordTransition(
            elements: afterResult.elements, icons: afterResult.icons,
            hints: afterResult.hints, screenshot: afterResult.screenshotBase64,
            actionType: "tap", elementText: target.text, screenType: screenType
        )

        // Also record in session for flat screen list
        session.capture(
            elements: afterResult.elements, hints: afterResult.hints,
            icons: afterResult.icons, actionType: "tap",
            arrivedVia: target.text, screenshotBase64: afterResult.screenshotBase64
        )

        lock.lock()
        actionCount += 1
        lock.unlock()

        switch transition {
        case .newScreen(let fp):
            lock.lock()
            backtrackStack.append(fp)
            actionsOnCurrentScreen = 0
            lock.unlock()
            return .continue(description: "Tapped \"\(target.text)\" → new screen (\(graph.nodeCount) total)")

        case .revisited:
            lock.lock()
            actionsOnCurrentScreen += 1
            lock.unlock()
            return .continue(description: "Tapped \"\(target.text)\" → revisited screen")

        case .duplicate:
            lock.lock()
            actionsOnCurrentScreen += 1
            lock.unlock()
            return .continue(description: "Tapped \"\(target.text)\" → no screen change")
        }
    }

    private func performBacktrack<S: ExplorationStrategy>(
        currentFP: String,
        input: InputProviding,
        describer: ScreenDescribing,
        strategy: S.Type,
        hints: [String]
    ) -> ExploreStepResult {
        lock.lock()
        let stackDepth = backtrackStack.count
        lock.unlock()

        // Can't backtrack past root
        guard stackDepth > 1 else {
            lock.lock()
            isFinished = true
            lock.unlock()
            return .finished(bundle: generateBundle())
        }

        // Fast-backtrack: skip multiple levels to reach tab root if beneficial
        if let fastResult = performFastBacktrackIfNeeded(stackDepth: stackDepth, input: input) {
            return fastResult
        }

        let backtrackAction = strategy.backtrackMethod(
            currentHints: hints, depth: stackDepth - 1
        )

        // Execute backtrack action
        switch backtrackAction {
        case .pressBack:
            _ = input.pressKey(keyName: "[", modifiers: ["command"])
        case .swipeBack:
            _ = input.swipe(fromX: 10, fromY: 400, toX: 300, toY: 400, durationMs: 300)
        case .pressHome:
            _ = input.pressKey(keyName: "h", modifiers: ["command", "shift"])
        case .none:
            lock.lock()
            isFinished = true
            lock.unlock()
            return .finished(bundle: generateBundle())
        }

        // Wait for navigation to complete
        usleep(EnvConfig.stepSettlingDelayMs * 1000)

        lock.lock()
        let fromFP = backtrackStack.removeLast()
        actionsOnCurrentScreen = 0
        lock.unlock()

        let toFP = graph.currentFingerprint
        return .backtracked(from: fromFP, to: toFP)
    }

    /// Fast-backtrack to root for tab-based apps when deep in a subtree.
    /// Instead of pressing Cmd+[ once per level, presses it (depth-1) times in one step.
    ///
    /// Triggers when:
    /// 1. Stack depth > 2 (at least 2 levels above root)
    /// 2. Root screen is a tabRoot
    /// 3. Root has unvisited elements (likely unexplored tabs)
    private func performFastBacktrackIfNeeded(
        stackDepth: Int,
        input: InputProviding
    ) -> ExploreStepResult? {
        guard stackDepth > 2 else { return nil }
        guard graph.rootScreenType() == .tabRoot else { return nil }
        guard graph.hasUnvisitedElements(for: graph.rootFingerprint) else { return nil }

        let stepsToRoot = stackDepth - 1
        for _ in 0..<stepsToRoot {
            _ = input.pressKey(keyName: "[", modifiers: ["command"])
            usleep(EnvConfig.stepSettlingDelayMs * 1000)
        }

        lock.lock()
        let previousFP = backtrackStack.last ?? ""
        // Pop entire stack down to root
        while backtrackStack.count > 1 {
            backtrackStack.removeLast()
        }
        actionsOnCurrentScreen = 0
        lock.unlock()

        let rootFP = graph.rootFingerprint
        return .backtracked(from: previousFP, to: rootFP)
    }

    /// Attempt to scroll the current screen to reveal hidden elements.
    /// Returns a step result if scrolling revealed new elements, or nil to fall through to backtrack.
    private func performScrollIfAvailable(
        currentFP: String,
        input: InputProviding,
        describer: ScreenDescribing
    ) -> ExploreStepResult? {
        guard graph.scrollCount(for: currentFP) < budget.scrollLimit else { return nil }

        // Swipe up (scroll content down) from center of screen
        let centerX = windowSize.width / 2
        let fromY = windowSize.height * 0.75
        let toY = windowSize.height * 0.25
        _ = input.swipe(fromX: centerX, fromY: fromY, toX: centerX, toY: toY, durationMs: 300)

        usleep(EnvConfig.stepSettlingDelayMs * 1000)

        // OCR the new viewport
        guard let afterResult = describer.describe(skipOCR: false) else { return nil }

        let novelCount = graph.mergeScrolledElements(
            fingerprint: currentFP, newElements: afterResult.elements
        )
        graph.incrementScrollCount(for: currentFP)

        if novelCount > 0 {
            return .continue(description: "Scrolled, found \(novelCount) new elements")
        }
        // No new elements — scroll exhaustion, fall through to backtrack
        return nil
    }

    /// OCR the screen and dismiss any detected iOS alert before returning the result.
    /// If no alert is detected, the initial OCR result is returned directly (zero overhead).
    /// Retries up to `AlertDetector.maxDismissAttempts` times for persistent alerts.
    private func dismissAlertIfPresent(
        describer: ScreenDescribing,
        input: InputProviding
    ) -> ScreenDescriber.DescribeResult? {
        guard var result = describer.describe(skipOCR: false) else { return nil }

        for _ in 0..<AlertDetector.maxDismissAttempts {
            guard let alert = AlertDetector.detectAlert(elements: result.elements) else {
                return result
            }
            // Tap the dismiss target
            _ = input.tap(x: alert.dismissTarget.tapX, y: alert.dismissTarget.tapY)
            usleep(EnvConfig.stepSettlingDelayMs * 1000)
            // Re-OCR to get clean screen
            guard let cleanResult = describer.describe(skipOCR: false) else { return nil }
            result = cleanResult
        }

        // After max attempts, return whatever we have
        return result
    }

    private func generateBundle() -> SkillBundle {
        guard let data = session.finalize() else {
            return SkillBundle(appName: "", skills: [], manifest: nil)
        }
        return SkillBundleGenerator.generate(
            appName: data.appName, goal: data.goal,
            snapshot: data.graphSnapshot, allScreens: data.screens
        )
    }
}
